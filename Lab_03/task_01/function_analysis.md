
```javascript
// Универсальная обертка для выполнения API запросов с обработкой ошибок
async function apiRequest(endpoint, options = {}) {
    const BASE_URL = 'https://api.example.com';
    const url = `${BASE_URL}${endpoint}`;

    const defaultHeaders = {
        'Content-Type': 'application/json',
    };

    try {
        // 1. Выполняем запрос
        const response = await fetch(url, {
            ...options,
            headers: {
                ...defaultHeaders,
                ...options.headers
            }
        }); // Здесь закрываем fetch

        // 2. Проверка на HTTP ошибки (4xx и 5xx), так как fetch сам не кидает catch на них
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.message || `HTTP error: ${response.status}`);
        }

        // 3. Возвращаем данные
        return await response.json();

    } catch (error) { // Исправлена скобка здесь
        console.error('API Request Error:', error.message);
        throw error; // Пробрасываем ошибку дальше
    }
}
```
# Анализ утилитарной функции: API Request Wrapper

### 1. Какую проблему она решает?
Стандартный метод `fetch` в JavaScript имеет несколько неудобств:
* Он не выбрасывает ошибки для HTTP статусов 4xx и 5xx, что затрудняет обработку ошибок.
* Требует ручного написания кода для парсинга JSON и обработки заголовков.
* Приводит к дублированию кода при выполнении множества API запросов.
Универсальная обертка `apiRequest` решает эти проблемы, предоставляя единый интерфейс для выполнения запросов с встроенной обработкой ошибок и парсингом JSON.

### 2. В каких контекстах она используется?
Функция используется в веб-приложениях (SPA), которые активно взаимодействует с внешними или внутренними REST API. Она служит промежуточночным слоем между логикой компонентов и сетевыми запросами.

### 3. Как именно она решает задачу?
Функция реализует паттерн 'Обертка' (Wrapper/Proxy):
* **Централизация:** Установливает базовый URL и стандартные заголовки в одном месте.
* **Автоматизация:** Самостоятельный вызов `.json()` после успешного ответа.
* **Безопасность:** Проверяет свойство `response.ok` и принудительно выбрасывает ошибку, если сервер вернул негативный статус, что позволяет использовать стандартный `try...catch` при вызове.

### 4. Ключевые компоненты решения
* **Конфигурация:** Объеденение стандартных и пользовательских настроек (headers, oprions).
* **Обработка ответа:** Проверка статуса ответа сервера.
* **Парсинг:** Преобразование сырого потока данных в JSON.
* **Логирование ошибок:** Единая точка для вывода ошибок в консоль.